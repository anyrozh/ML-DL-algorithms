# -*- coding: utf-8 -*-
"""Линейная_функция.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eDGOVesSmq069nkApIvvcjfKJoH2k13P

**Инициализация класса**
"""

class MyLineReg:
  def __init__(self, n_iter = 100, learning_rate = 0.1):
    self.n_iter = n_iter
    self.learning_rate = learning_rate
  def __str__(self):
        return f"MyLineReg class: n_iter={self.n_iter}, learning_rate={self.learning_rate}"
  __repr__ = __str__

model = MyLineReg(n_iter=10, learning_rate=0.5)
model

"""**Обучение**

1. На вход принимать три атрибута:
- X — все фичи в виде датафрейма пандаса.
  Примечание: даже если фича будет всего одна это все равно будет датафрейм, а не серия.
- y — целевая переменная в виде пандасовской серии.
- verbose — указывает на какой итерации выводить лог. Например, значение 10 означает, что на каждой 10 итерации градиентного спуска будет печататься лог. Значение по умолчанию: False (т.е. ничего не выводится).

2. Дополнить переданную матрицу фичей единичным столбцом слева.
3. Определить сколько фичей передано и создать вектор весов, состоящий из одних единиц соответствующей длинны: т.е. количество фичей + 1.

X_.shape == (10, 3)

то это значит, что:
- `X_.shape[0]` — это **количество строк** (в данном примере 10),
- `X_.shape[1]` — это **количество столбцов** (в данном примере 3).

Дальше в цикле (до n_iter):
- Предсказать
y
^
y
^
​

- Посчитать ошибку (MSE)
- Вычислить градиент
- Сделать шаг размером learning rate в противоположную от градиента сторону
- Сохранить обновленные веса внутри класса

Необходимо реализовать метод get_coef, который будет возвращать значения весов в виде вектора NumPy, начиная со второго значения. Первое значение нам не нужно, потому что оно соответствует фиктивной фиче (единичке). Все же остальные могут использоваться для оценки важности фичей.
"""

import numpy as np
import pandas as pd

class MyLineReg():
    def __init__(self, n_iter=100, learning_rate=0.1, weights=None, metric = None):
        self.n_iter = n_iter
        self.learning_rate = learning_rate
        self.weights = weights
        self.metric = [mae,rmse,mape,r2]

    def __str__(self):
        return f"MyLineReg class: n_iter={self.n_iter}, learning_rate={self.learning_rate}"
    __repr__ = __str__

    def fit(self, X, y, verbose=False):
        X_ = np.hstack([np.ones((X.shape[0], 1)), X.values])
        n_features = X_.shape[1]
        self.weights = np.ones(n_features)
        n = X_.shape[0]
        y_pred = X_ @ self.weights
        loss = ((y_pred - y.values)**2).mean()
        if verbose:
            print (f"start|loss:{loss:.2f}")
        for i in range(1, self.n_iter+1):
            y_pred = X_ @ self.weights
            mse_error = y_pred - y.values
            grad = (2/n) * X_.T @ mse_error
            self.weights -= self.learning_rate * grad
            if verbose and isinstance(verbose, int) and  i % verbose == 0:
                loss = ((X_ @ self.weights - y.values)**2).mean()
                print(f"{i} | loss: {loss:.2f}")

    def get_coef(self):
        return self.weights[1:]

X = pd.DataFrame({'x1': [1,2,3], 'x2':[2,3,4]})
y = pd.Series([5,7,9])

reg = MyLineReg()
reg.fit(X, y)

reg.get_coef()

"""**Предсказание**

Добавьте в класс MyLineReg метод predict. Данный метод должен делать следующее:

На вход принимать матрицу фичей в виде датафрейма пандаса.
Дополнять матрицу фичей единичным вектором (первый столбец).
Возвращать вектор предсказаний.
Напомню, что предсказание выполняется следующим образом:
y
^
=
X
W
y
^
​
 =XW
где:
-
X
X - матрица фичей
-
W
W - вектор весов

Добавьте в класс MyLineReg параметр metric, который будет принимать одно из следующих значений:
- mae
- mse
- rmse
- mape
- r2
По умолчанию: None
"""

import numpy as np
import pandas as pd

class MyLineReg():
    def __init__(self, n_iter=100, learning_rate=0.1, weights=None):
        self.n_iter = n_iter
        self.learning_rate = learning_rate
        self.weights = weights

    def __str__(self):
        return f"MyLineReg class: n_iter={self.n_iter}, learning_rate={self.learning_rate}"
    __repr__ = __str__


    def fit(self, X, y, verbose=False):
        X_ = np.hstack([np.ones((X.shape[0], 1)), X.values])
        n_features = X_.shape[1]
        self.weights = np.ones(n_features)
        n = X_.shape[0]
        y_pred = X_ @ self.weights
        loss = ((y_pred - y.values)**2).mean()
        if verbose:
            print (f"start|loss:{loss:.2f}")
        for i in range(1, self.n_iter+1):
            y_pred = X_ @ self.weights
            mse_error = y_pred - y.values
            grad = (2/n) * X_.T @ mse_error
            self.weights -= self.learning_rate * grad
            if verbose and isinstance(verbose, int) and i % verbose == 0:
                loss = ((X_ @ self.weights - y.values)**2).mean()
                print(f"{i} | loss: {loss:.2f}")

    def get_coef(self):
        return self.weights[1:]

    def predict(self, X):
        X_ = np.hstack([np.ones((X.shape[0], 1)), X.values])
        return X_ @ self.weights

"""**Метрики** - MSE возводит ошибки в квадрат, а значит сильнее штрафует за большие отклонения, и поэтому более чувствительна к выбросам.


*   По сравнению с MSE, MAE хуже "борется" с выбросами. Но MAE гораздо лучше интерпретируется: по сути это просто средняя ошибка вашей модели в абсолютных величинах.


*   RMSE это по сути тот же MSE, только из него берут корень, чтобы размерность была схожа с исходными данными.

*   Коэффициент детерминации измеряет долю дисперсии, объясненную моделью, в общей дисперсии целевой переменной. Фактически, данная мера качества это нормированная среднеквадратичная ошибка. Если она близка к единице, то модель хорошо объясняет данные, если же она близка к нулю, то прогнозы сопоставимы по качеству с константным предсказанием.


*   MAPE - Если у вас получилось, например, что MAPE = 11.4%, то это говорит о том, что ошибка составила 11,4% от фактических значений. Основная проблема данной ошибки — нестабильность. **Из-за деления на фактические значения эта метрика чувствительна к масштабу.**


"""

import numpy as np

class MyLineReg():
    def __init__(self, n_iter=100, learning_rate=0.1, weights=None, metric=None):
        self.n_iter = n_iter
        self.learning_rate = learning_rate
        self.weights = weights
        self.metric = metric
        self._last_metric_score = None   # для хранения значения метрики после обучения

    def __str__(self):
        return f"MyLineReg class: n_iter={self.n_iter}, learning_rate={self.learning_rate}"
    __repr__ = __str__

    def _calc_metric(self, y_true, y_pred):
        if self.metric is None:
            return None
        if self.metric == 'mae':
            return np.mean(np.abs(y_true - y_pred))
        elif self.metric == 'mse':
            return np.mean((y_true - y_pred) ** 2)
        elif self.metric == 'rmse':
            return np.sqrt(np.mean((y_true - y_pred) ** 2))
        elif self.metric == 'mape':
            y_true_nonzero = np.where(y_true == 0, 1e-8, y_true)
            return np.mean(np.abs((y_true - y_pred) / y_true_nonzero)) * 100
        elif self.metric == 'r2':
            return 1 - np.sum((y_true - y_pred) ** 2) / np.sum((y_true - np.mean(y_true)) ** 2)
        else:
            raise ValueError('Unknown metric:' + str(self.metric))

    def fit(self, X, y, verbose=False):
        X_ = np.hstack([np.ones((X.shape[0], 1)), X.values])
        n_features = X_.shape[1]
        self.weights = np.ones(n_features)
        n = X_.shape[0]
        y_pred = X_ @ self.weights
        loss = ((y_pred - y.values) ** 2).mean()
        if verbose:
            if self.metric is not None:
                metric_val = self._calc_metric(y.values, y_pred)
                print(f"start | loss: | {self.metric}: {metric_val:.2f}")
            else:
                print(f"start | loss:{loss:.2f}")
        for i in range(1, self.n_iter + 1):
            y_pred = X_ @ self.weights
            mse_error = y_pred - y.values
            grad = (2 / n) * X_.T @ mse_error
            self.weights -= self.learning_rate * grad
            if verbose and isinstance(verbose, int) and i % verbose == 0:
                loss = ((X_ @ self.weights - y.values) ** 2).mean()
                if self.metric is not None:
                    metric_val = self._calc_metric(y.values, X_ @ self.weights)
                    print(f"{i} | loss: | {self.metric}: {metric_val:.2f}")
                else:
                    print(f"{i} | loss: {loss:.2f}")
        # Сохраняем последнее значение метрики после обучения
        if self.metric is not None:
            self._last_metric_score = self._calc_metric(y.values, X_ @ self.weights)

    def get_coef(self):
        return self.weights[1:]

    def predict(self, X):
        X_ = np.hstack([np.ones((X.shape[0], 1)), X.values])
        return X_ @ self.weights

    def get_best_score(self):
        """
        Возвращает последнее значение метрики (на тренировочной выборке после fit)
        """
        return self._last_metric_score

"""**Регуляризация**

Абсолютно для всех алгоритмов машинного обучения регуляризация делает одно и то же — **борется со сложностью модели.** А чересчур сложная **модель это прямой путь к переобучению. Но в разных алгоритмах сложность может проявляться по-разному.** В линейных моделях сложность проявляется в больших значениях весов

пример - 1x(0)+10000x(1) +2x(2)=y

Достигается это путем штрафования функции потерь за большие веса. Рассмотрим три основные регуляризации в линейных моделях...

1. L1 регуляризация (или Lasso регрессия)
2. L2 регуляризация
3. ElasticNet Это комбинация регуляризаций L1 и L2

Добавьте в класс MyLineReg три параметра:
reg – принимает одно из трех значений: l1, l2, elasticnet
По умолчанию: None
l1_coef – принимает значения от 0.0 до 1.0
По умолчанию: 0
l2_coef – принимает значения от 0.0 до 1.0
По умолчанию: 0
Добавьте регуляризацию к вычислению лоса.
Добавьте регуляризацию к вычислению градиента.
Примечания:

Для вычисления регуляризации L1 вам нужно задать reg="l1" и указать только l1_coef.
Для вычисления L2 вам нужно задать reg="l2" и указать только l2_coef.
Для вычисления Elasticnet вам нужно задать reg="elasticnet" и указать оба параметра l1_coef и l2_coef.
"""

import numpy as np

class MyLineReg():
    def __init__(self, n_iter=100, learning_rate=0.1, weights=None, metric=None,
                 reg=None, l1_coef=0, l2_coef=0):
        self.n_iter = n_iter
        self.learning_rate = learning_rate
        self.weights = weights
        self.metric = metric
        self.reg = reg
        self.l1_coef = l1_coef
        self.l2_coef = l2_coef
        self._last_metric_score = None

    def __str__(self):
        return f"MyLineReg class: n_iter={self.n_iter}, learning_rate={self.learning_rate}"
    __repr__ = __str__

    def _calc_metric(self, y_true, y_pred):
        if self.metric is None:
            return None
        if self.metric == 'mae':
            return np.mean(np.abs(y_true - y_pred))
        elif self.metric == 'mse':
            return np.mean((y_true - y_pred) ** 2)
        elif self.metric == 'rmse':
            return np.sqrt(np.mean((y_true - y_pred) ** 2))
        elif self.metric == 'mape':
            y_true_nonzero = np.where(y_true == 0, 1e-8, y_true)
            return np.mean(np.abs((y_true - y_pred) / y_true_nonzero)) * 100
        elif self.metric == 'r2':
            return 1 - np.sum((y_true - y_pred) ** 2) / np.sum((y_true - np.mean(y_true)) ** 2)
        else:
            raise ValueError('Unknown metric:' + str(self.metric))

    def _regularization_loss(self, w):
        if self.reg is None:
            return 0
        elif self.reg == 'l1':
            return self.l1_coef * np.sum(np.abs(w))
        elif self.reg == 'l2':
            return self.l2_coef * np.sum(w ** 2)
        elif self.reg == 'elasticnet':
            return self.l1_coef * np.sum(np.abs(w)) + self.l2_coef * np.sum(w ** 2)
        else:
            raise ValueError('Unknown regularization:' + str(self.reg))

    def _regularization_grad(self, w):
        if self.reg is None:
            return np.zeros_like(w)
        elif self.reg == 'l1':
            return self.l1_coef * np.sign(w)
        elif self.reg == 'l2':
            return 2 * self.l2_coef * w
        elif self.reg == 'elasticnet':
            return self.l1_coef * np.sign(w) + 2 * self.l2_coef * w
        else:
            raise ValueError('Unknown regularization:' + str(self.reg))

    def fit(self, X, y, verbose=False):
        X_ = np.hstack([np.ones((X.shape[0], 1)), X.values])
        n_features = X_.shape[1]
        self.weights = np.ones(n_features)
        n = X_.shape[0]

        y_pred = X_ @ self.weights
        loss = np.mean((y_pred - y.values) ** 2) + self._regularization_loss(self.weights)
        if verbose:
            if self.metric is not None:
                metric_val = self._calc_metric(y.values, y_pred)
                print(f"start | loss: {loss:.4f} | {self.metric}: {metric_val:.2f}")
            else:
                print(f"start | loss:{loss:.4f}")

        for i in range(1, self.n_iter + 1):
            y_pred = X_ @ self.weights
            mse_error = y_pred - y.values
            grad = (2 / n) * X_.T @ mse_error + self._regularization_grad(self.weights)
            self.weights -= self.learning_rate * grad

            if verbose and isinstance(verbose, int) and i % verbose == 0:
                loss = np.mean((X_ @ self.weights - y.values) ** 2) + self._regularization_loss(self.weights)
                if self.metric is not None:
                    metric_val = self._calc_metric(y.values, X_ @ self.weights)
                    print(f"{i} | loss: {loss:.4f} | {self.metric}: {metric_val:.2f}")
                else:
                    print(f"{i} | loss: {loss:.4f}")

        if self.metric is not None:
            self._last_metric_score = self._calc_metric(y.values, X_ @ self.weights)

    def get_coef(self):
        return self.weights[1:]

    def predict(self, X):
        X_ = np.hstack([np.ones((X.shape[0], 1)), X.values])
        return X_ @ self.weights

    def get_best_score(self):
        return self._last_metric_score

"""**Скорость обучения**

Более разумным было бы динамически менять шаг обучения в зависимости от сделанного количества шагов: **в начале двигаемся быстро, чтобы ускорить обучение, под конец замедляемся, чтобы не пропустить минимум.**
"""

# 1. С фиксированной скоростью
model1 = MyLineReg(learning_rate=0.1)  # обычный случай
# 2. С динамической скоростью
model2 = MyLineReg(learning_rate=lambda iter: 0.5 * (0.85 ** iter))
# 3. С выводом информации о скорости обучения
model3 = MyLineReg(
    n_iter=10,
    learning_rate=lambda iter: 0.5 * (0.85 ** iter),
    verbose=1
)
model3.fit(X, y)

import numpy as np

class MyLineReg():
    def __init__(self, n_iter=100, learning_rate=0.1, weights=None, metric=None,
                 reg=None, l1_coef=0, l2_coef=0):
        self.n_iter = n_iter
        self.learning_rate = learning_rate
        self.weights = weights
        self.metric = metric
        self.reg = reg
        self.l1_coef = l1_coef
        self.l2_coef = l2_coef
        self._last_metric_score = None

    def __str__(self):
        return f"MyLineReg class: n_iter={self.n_iter}, learning_rate={self.learning_rate}"
    __repr__ = __str__

    def _calc_metric(self, y_true, y_pred):
        if self.metric is None:
            return None
        if self.metric == 'mae':
            return np.mean(np.abs(y_true - y_pred))
        elif self.metric == 'mse':
            return np.mean((y_true - y_pred) ** 2)
        elif self.metric == 'rmse':
            return np.sqrt(np.mean((y_true - y_pred) ** 2))
        elif self.metric == 'mape':
            y_true_nonzero = np.where(y_true == 0, 1e-8, y_true)
            return np.mean(np.abs((y_true - y_pred) / y_true_nonzero)) * 100
        elif self.metric == 'r2':
            return 1 - np.sum((y_true - y_pred) ** 2) / np.sum((y_true - np.mean(y_true)) ** 2)
        else:
            raise ValueError('Unknown metric:' + str(self.metric))

    def _regularization_loss(self, w):
        if self.reg is None:
            return 0
        elif self.reg == 'l1':
            return self.l1_coef * np.sum(np.abs(w))
        elif self.reg == 'l2':
            return self.l2_coef * np.sum(w ** 2)
        elif self.reg == 'elasticnet':
            return self.l1_coef * np.sum(np.abs(w)) + self.l2_coef * np.sum(w ** 2)
        else:
            raise ValueError('Unknown regularization:' + str(self.reg))

    def _regularization_grad(self, w):
        if self.reg is None:
            return np.zeros_like(w)
        elif self.reg == 'l1':
            return self.l1_coef * np.sign(w)
        elif self.reg == 'l2':
            return 2 * self.l2_coef * w
        elif self.reg == 'elasticnet':
            return self.l1_coef * np.sign(w) + 2 * self.l2_coef * w
        else:
            raise ValueError('Unknown regularization:' + str(self.reg))

    def fit(self, X, y, verbose=False):
        X_ = np.hstack([np.ones((X.shape[0], 1)), X.values])
        n_features = X_.shape[1]
        self.weights = np.ones(n_features)
        n = X_.shape[0]

        y_pred = X_ @ self.weights
        loss = np.mean((y_pred - y.values) ** 2) + self._regularization_loss(self.weights)
        if verbose:
            if self.metric is not None:
                metric_val = self._calc_metric(y.values, y_pred)
                print(f"start | loss: {loss:.4f} | {self.metric}: {metric_val:.2f}")
            else:
                print(f"start | loss:{loss:.4f}")

        for i in range(1, self.n_iter + 1):
            # Вычисляем текущую скорость обучения
            current_lr = self.learning_rate(i) if callable(self.learning_rate) else self.learning_rate

            y_pred = X_ @ self.weights
            mse_error = y_pred - y.values
            grad = (2 / n) * X_.T @ mse_error + self._regularization_grad(self.weights)
            self.weights -= current_lr * grad

            if verbose and isinstance(verbose, int) and i % verbose == 0:
                loss = np.mean((X_ @ self.weights - y.values) ** 2) + self._regularization_loss(self.weights)
                if self.metric is not None:
                    metric_val = self._calc_metric(y.values, X_ @ self.weights)
                    print(f"{i} | lr: {current_lr:.4f} | loss: {loss:.4f} | {self.metric}: {metric_val:.2f}")
                else:
                    print(f"{i} | lr: {current_lr:.4f} | loss: {loss:.4f}")

        if self.metric is not None:
            self._last_metric_score = self._calc_metric(y.values, X_ @ self.weights)

    def get_coef(self):
        return self.weights[1:]

    def predict(self, X):
        X_ = np.hstack([np.ones((X.shape[0], 1)), X.values])
        return X_ @ self.weights

    def get_best_score(self):
        return self._last_metric_score

"""**Стохастический градиентный спуск**

Основная идея стохастического градиентного спуска (Stochastic Gradient Descent, SGD) состоит в том, что мы на каждом шаге вычисляем градиент функции потери не на всей обучающей выборке, а на небольшом ее подмножестве. - используется, когда выборка слишком большая и необходимо упростить вычисления.
![image.png](data:image/png;base64,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)

При этом шагов нам может потребоваться гораздо больше, чем при обычном градиентном спуске. Зато расчет каждого из них будет делаться значительно быстрее.

Во-первых, выделяют **подходы по количеству используемых объектов:**

1. Классический стохастический градиентный спуск предполагает использование на каждом шаге ровно одного образца из выборки. -> берем и отбираем пару значений из общей выборки, используем одно значений на шаг.
2. Пакетный подход (Mini-Batch) – на каждом шаге мы используем пакет из небольшого числа элементов обучающей выборки. Это позволяет уменьшить излишнюю “стохастичность” (случайность) градиентного спуска. -> берем несколько значений из выборки и обучаем несколько элементов из обучающей выборки.


Во-вторых, **SGD различаются по способу отбора объектов**:

1. В одном варианте **все экземпляры перебираются последовательно**. Когда объекты заканчиваются перебор начинается сначала пока не будет достигнуто заданное кол-во итераций.
2. В другом варианте на каждом шаге формируется случайная подвыборка элементов.
В нашей реализации мы задействуем случайный отбор заданного количества элементов.

*   Если задано целое число, то из исходного датасета берется ровно столько примеров сколько указано.
*   Если задано дробное число, то рассматриваем его как долю от количества строк в исходном датасете (округленное до целого числа).
"""

import numpy as np
import random

class MyLineReg():
    def __init__(self, n_iter=100, learning_rate=0.1, weights=None, metric=None,
                 reg=None, l1_coef=0, l2_coef=0, sgd_sample=None, random_state=42):
        self.n_iter = n_iter
        self.learning_rate = learning_rate
        self.weights = weights
        self.metric = metric
        self.reg = reg
        self.l1_coef = l1_coef
        self.l2_coef = l2_coef
        #sgd_sample – кол-во образцов, которое будет использоваться на каждой итерации обучения. Может принимать либо целые числа, либо дробные от 0.0 до 1.0.
        self.sgd_sample = sgd_sample
        self.random_state = random_state
        self._last_metric_score = None

    def __str__(self):
        return f"MyLineReg class: n_iter={self.n_iter}, learning_rate={self.learning_rate}, sgd_sample={self.sgd_sample}"
    __repr__ = __str__

    def _calc_metric(self, y_true, y_pred):
        if self.metric is None:
            return None
        if self.metric == 'mae':
            return np.mean(np.abs(y_true - y_pred))
        elif self.metric == 'mse':
            return np.mean((y_true - y_pred) ** 2)
        elif self.metric == 'rmse':
            return np.sqrt(np.mean((y_true - y_pred) ** 2))
        elif self.metric == 'mape':
            y_true_nonzero = np.where(y_true == 0, 1e-8, y_true)
            return np.mean(np.abs((y_true - y_pred) / y_true_nonzero)) * 100
        elif self.metric == 'r2':
            return 1 - np.sum((y_true - y_pred) ** 2) / np.sum((y_true - np.mean(y_true)) ** 2)
        else:
            raise ValueError('Unknown metric:' + str(self.metric))

    def _regularization_loss(self, w):
        if self.reg is None:
            return 0
        elif self.reg == 'l1':
            return self.l1_coef * np.sum(np.abs(w))
        elif self.reg == 'l2':
            return self.l2_coef * np.sum(w ** 2)
        elif self.reg == 'elasticnet':
            return self.l1_coef * np.sum(np.abs(w)) + self.l2_coef * np.sum(w ** 2)
        else:
            raise ValueError('Unknown regularization:' + str(self.reg))

    def _regularization_grad(self, w):
        if self.reg is None:
            return np.zeros_like(w)
        elif self.reg == 'l1':
            return self.l1_coef * np.sign(w)
        elif self.reg == 'l2':
            return 2 * self.l2_coef * w
        elif self.reg == 'elasticnet':
            return self.l1_coef * np.sign(w) + 2 * self.l2_coef * w
        else:
            raise ValueError('Unknown regularization:' + str(self.reg))

    def fit(self, X, y, verbose=False):
        random.seed(self.random_state)
        X_ = np.hstack([np.ones((X.shape[0], 1)), X.values])
        n_features = X_.shape[1]
        self.weights = np.ones(n_features)
        n = X_.shape[0]

        # Определяем размер мини-пакета
        if self.sgd_sample is not None:
            if isinstance(self.sgd_sample, float) and 0 < self.sgd_sample < 1:
                sample_size = int(round(n * self.sgd_sample))
            else:
                sample_size = int(self.sgd_sample)
        else:
            sample_size = n

        y_pred = X_ @ self.weights
        loss = np.mean((y_pred - y.values) ** 2) + self._regularization_loss(self.weights)
        if verbose:
            if self.metric is not None:
                metric_val = self._calc_metric(y.values, y_pred)
                print(f"start | loss: {loss:.4f} | {self.metric}: {metric_val:.2f}")
            else:
                print(f"start | loss:{loss:.4f}")

        for i in range(1, self.n_iter + 1):
            # Вычисляем текущую скорость обучения
            current_lr = self.learning_rate(i) if callable(self.learning_rate) else self.learning_rate

            # Формируем мини-пакет
            if self.sgd_sample is not None:
                sample_rows_idx = random.sample(range(n), sample_size)
                X_batch = X_[sample_rows_idx]
                y_batch = y.values[sample_rows_idx]
            else:
                X_batch = X_
                y_batch = y.values

            # Вычисляем градиент на мини-пакете
            y_pred_batch = X_batch @ self.weights
            mse_error_batch = y_pred_batch - y_batch
            grad = (2 / len(X_batch)) * X_batch.T @ mse_error_batch + self._regularization_grad(self.weights)

            self.weights -= current_lr * grad

            # Вычисляем ошибку и метрику на всем датасете
            y_pred_full = X_ @ self.weights
            loss = np.mean((y_pred_full - y.values) ** 2) + self._regularization_loss(self.weights)

            if verbose and isinstance(verbose, int) and i % verbose == 0:
                if self.metric is not None:
                    metric_val = self._calc_metric(y.values, y_pred_full)
                    print(f"{i} | lr: {current_lr:.4f} | loss: {loss:.4f} | {self.metric}: {metric_val:.2f}")
                else:
                    print(f"{i} | lr: {current_lr:.4f} | loss: {loss:.4f}")

        if self.metric is not None:
            self._last_metric_score = self._calc_metric(y.values, X_ @ self.weights)

    def get_coef(self):
        return self.weights[1:]

    def predict(self, X):
        X_ = np.hstack([np.ones((X.shape[0], 1)), X.values])
        return X_ @ self.weights

    def get_best_score(self):
        return self._last_metric_score